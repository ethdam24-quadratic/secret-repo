{
  "language": "Solidity",
  "sources": {
    "contracts/Funding.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\nimport \"../interfaces/IGateway.sol\";\nimport \"./JsmnSolLib.sol\";\n\n/**\n * A smart contract for cross-chain quadratic voting developed during EthDam 24.\n * This contract supports various types of funding curves and ensures privacy and security through integration with the Secret Network.\n * @author arjanjohan\n */\ncontract Funding {\n\t// ========================================\n\t//     ENUM, STRUCTS AND MAPPINGS\n\t// ========================================\n\n\tstruct Project {\n\t\tuint256 id;\n\t\tstring name;\n\t\tstring description;\n\t\taddress payable projectAddress;\n\t\tuint256 totalContributions;\n\t\tuint256 totalSquareRoots;\n\t}\n\n\tstruct FundingRound {\n\t\tuint256 id;\n\t\tstring name;\n\t\tstring description;\n\t\tstring curveType;\n\t\tmapping(uint256 => Project) projects;\n\t\tuint256[] projectIds;\n\t\tuint256 totalContributions;\n\t\tbool isOpen;\n\t}\n\n\tstruct ProjectFundingData {\n\t\tstring projectId;\n\t\tuint256 fundingPercentage;\n\t}\n\n\tmapping(uint256 => FundingRound) public fundingRounds;\n\tuint256[] public roundIds;\n\n\t// ========================================\n\t//     CONSTRUCTOR AND VALUES\n\t// ========================================\n\n\tIGateway public gatewayContract;\n\taddress public constant gatewayAddressSepolia =\n\t\taddress(0x3879E146140b627a5C858a08e507B171D9E43139);\n\n\tconstructor() {\n\t\tgatewayContract = IGateway(gatewayAddressSepolia);\n\t}\n\n\t// ========================================\n\t//     EVENTS\n\t// ========================================\n\tevent RoundCreated(\n\t\tuint256 indexed roundId,\n\t\tstring name,\n\t\tuint256[] projectIds\n\t);\n\n\tevent RoundCreatedInSecret(uint256 indexed roundId);\n\n\tevent ContributionReceived(address indexed contributor);\n\n\tevent ContributionReceivedInSecret(uint256 indexed roundId);\n\n\tevent RoundClosed(uint256 indexed roundId);\n\n\tevent RoundClosedInSecret(uint256 indexed roundId);\n\n\tevent DistributedTokens(uint256 indexed roundId);\n\n\tevent DistributedTokensInSecret(uint256 indexed roundId);\n\n\t// ========================================\n\t//     CORE FUNCTIONS\n\t// ========================================\n\n\tfunction createFundingRound(\n\t\tuint256 id,\n\t\tstring memory name,\n\t\tstring memory description,\n\t\tstring memory curveType,\n\t\tuint256[] memory projectIds,\n\t\tstring[] memory projectNames,\n\t\tstring[] memory projectDescriptions,\n\t\taddress payable[] memory projectAddresses,\n\t\taddress userAddress,\n\t\tbool sendToSecret,\n\t\tbytes32 payloadHash,\n\t\tstring calldata routingInfo,\n\t\tIGateway.ExecutionInfo calldata info\n\t) public payable {\n\t\tvalidateProjectParameters(\n\t\t\tprojectIds,\n\t\t\tprojectNames,\n\t\t\tprojectDescriptions,\n\t\t\tprojectAddresses\n\t\t);\n\t\trequire(fundingRounds[id].id == 0, \"Round ID exists\");\n\n\t\tif (sendToSecret) {\n\t\t\tgatewayContract.send{ value: msg.value }(\n\t\t\t\tpayloadHash,\n\t\t\t\tuserAddress,\n\t\t\t\troutingInfo,\n\t\t\t\tinfo\n\t\t\t);\n\t\t}\n\n\t\tFundingRound storage round = fundingRounds[id];\n\t\tsetupFundingRound(\n\t\t\tround,\n\t\t\tid,\n\t\t\tname,\n\t\t\tdescription,\n\t\t\tcurveType,\n\t\t\tprojectIds,\n\t\t\tprojectNames,\n\t\t\tprojectDescriptions,\n\t\t\tprojectAddresses\n\t\t);\n\t\troundIds.push(id);\n\t\temit RoundCreated(id, name, projectIds);\n\t}\n\n\t// callback function for secret\n\tfunction createdFundingRound(uint256 roundId, bytes memory json) public {\n\t\temit RoundCreatedInSecret(roundId);\n\t}\n\n\tfunction contribute(\n\t\taddress userAddress,\n\t\tbytes32 payloadHash,\n\t\tstring calldata routingInfo,\n\t\tIGateway.ExecutionInfo calldata info\n\t) public payable {\n\t\tgatewayContract.send{ value: msg.value }( // todo change this value\n\t\t\tpayloadHash,\n\t\t\tuserAddress,\n\t\t\troutingInfo,\n\t\t\tinfo\n\t\t);\n\t\temit ContributionReceived(msg.sender);\n\t}\n\n\t// callback function for secret\n\tfunction contributed(uint256 roundId, bytes memory json) public {\n\t\temit ContributionReceivedInSecret(roundId);\n\t}\n\n\tfunction closeFundingRound(\n\t\tuint256 roundId,\n\t\tbytes32 payloadHash,\n\t\tstring calldata routingInfo,\n\t\tIGateway.ExecutionInfo calldata info\n\t) public payable {\n\t\trequire(fundingRounds[roundId].isOpen, \"Round closed\");\n\t\tfundingRounds[roundId].isOpen = false;\n\n\t\tgatewayContract.send{ value: msg.value }(\n\t\t\tpayloadHash,\n\t\t\tmsg.sender,\n\t\t\troutingInfo,\n\t\t\tinfo\n\t\t);\n\n\t\temit RoundClosed(roundId);\n\t}\n\n\t// callback function for secret\n\tfunction closedFundingRound(uint256 roundId, bytes memory json) public {\n\t\temit RoundClosedInSecret(roundId);\n\t}\n\n\tfunction distributeFunding(\n\t\tuint256 roundId,\n\t\tbytes32 payloadHash,\n\t\tstring calldata routingInfo,\n\t\tIGateway.ExecutionInfo calldata info\n\t) public payable {\n\t\trequire(!fundingRounds[roundId].isOpen, \"Round is not closed\");\n\t\tgatewayContract.send{ value: msg.value }(\n\t\t\tpayloadHash,\n\t\t\tmsg.sender,\n\t\t\troutingInfo,\n\t\t\tinfo\n\t\t);\n\n\t\temit RoundClosed(roundId);\n\t}\n\n\t// callback function for secret\n\tfunction distributedFunding(uint256 roundId, bytes memory json) public {\n\t\tProjectFundingData[] memory fundingData = parseFundingData(\n\t\t\tstring(json)\n\t\t);\n\t\tprocessFundingRound(fundingData, roundId);\n\t\temit RoundClosedInSecret(roundId);\n\t}\n\n\t// ========================================\n\t//     HELPER FUNCTIONS\n\t// ========================================\n\n\tfunction validateProjectParameters(\n\t\tuint256[] memory projectIds,\n\t\tstring[] memory projectNames,\n\t\tstring[] memory projectDescriptions,\n\t\taddress payable[] memory projectAddresses\n\t) private pure {\n\t\trequire(\n\t\t\tprojectIds.length == projectNames.length &&\n\t\t\t\tprojectNames.length == projectDescriptions.length &&\n\t\t\t\tprojectDescriptions.length == projectAddresses.length,\n\t\t\t\"Mismatched input arrays\"\n\t\t);\n\t}\n\n\tfunction setupFundingRound(\n\t\tFundingRound storage round,\n\t\tuint256 id,\n\t\tstring memory name,\n\t\tstring memory description,\n\t\tstring memory curveType,\n\t\tuint256[] memory projectIds,\n\t\tstring[] memory projectNames,\n\t\tstring[] memory projectDescriptions,\n\t\taddress payable[] memory projectAddresses\n\t) private {\n\t\tround.id = id;\n\t\tround.name = name;\n\t\tround.description = description;\n\t\tround.curveType = curveType;\n\t\tround.isOpen = true;\n\n\t\tfor (uint256 i = 0; i < projectIds.length; i++) {\n\t\t\trequire(round.projects[projectIds[i]].id == 0, \"Project ID exists\");\n\t\t\tround.projects[projectIds[i]] = Project({\n\t\t\t\tid: projectIds[i],\n\t\t\t\tname: projectNames[i],\n\t\t\t\tdescription: projectDescriptions[i],\n\t\t\t\tprojectAddress: projectAddresses[i],\n\t\t\t\ttotalContributions: 0,\n\t\t\t\ttotalSquareRoots: 0\n\t\t\t});\n\t\t\tround.projectIds.push(projectIds[i]);\n\t\t}\n\t}\n\n\tfunction validRound(uint256 roundId) private view returns (bool) {\n\t\treturn fundingRounds[roundId].isOpen && fundingRounds[roundId].id != 0;\n\t}\n\n\t// Parses the JSON and extracts funding data\n\tfunction parseFundingData(\n\t\tstring memory json\n\t) internal pure returns (ProjectFundingData[] memory) {\n\t\tuint256 numTokens;\n\t\tJsmnSolLib.Token[] memory tokens;\n\t\t(, tokens, numTokens) = JsmnSolLib.parse(json, 20);\n\t\trequire(numTokens > 0, \"JSON parsing failed or no data found\");\n\n\t\tProjectFundingData[] memory results = new ProjectFundingData[](\n\t\t\t(numTokens - 1) / 3\n\t\t);\n\t\tfor (uint256 i = 0; i < results.length; i++) {\n\t\t\tstring memory projectId = JsmnSolLib.getBytes(\n\t\t\t\tjson,\n\t\t\t\ttokens[1 + 3 * i].start,\n\t\t\t\ttokens[1 + 3 * i].end\n\t\t\t);\n\t\t\tstring memory percentageStr = JsmnSolLib.getBytes(\n\t\t\t\tjson,\n\t\t\t\ttokens[2 + 3 * i].start,\n\t\t\t\ttokens[2 + 3 * i].end\n\t\t\t);\n\t\t\tuint256 fundingPercentage = uint256(\n\t\t\t\tJsmnSolLib.parseInt(percentageStr)\n\t\t\t);\n\t\t\tresults[i] = ProjectFundingData(projectId, fundingPercentage);\n\t\t}\n\t\treturn results;\n\t}\n\n\t// Processes each project's funding based on parsed data\n\tfunction processFundingRound(\n\t\tProjectFundingData[] memory fundingData,\n\t\tuint256 roundId\n\t) internal {\n\t\tuint256 totalFunds = fundingRounds[roundId].totalContributions;\n\t\tfor (uint256 i = 0; i < fundingRounds[roundId].projectIds.length; i++) {\n\t\t\tProject storage project = fundingRounds[roundId].projects[\n\t\t\t\tfundingRounds[roundId].projectIds[i]\n\t\t\t];\n\t\t\tuint256 payout = calculatePayout(project, fundingData);\n\t\t\tproject.projectAddress.transfer(payout);\n\t\t\ttotalFunds -= payout;\n\t\t}\n\t}\n\n\t// Calculates the payout for a given project\n\tfunction calculatePayout(\n\t\tProject storage project,\n\t\tProjectFundingData[] memory fundingData\n\t) internal view returns (uint256) {\n\t\tfor (uint256 i = 0; i < fundingData.length; i++) {\n\t\t\tif (\n\t\t\t\tkeccak256(bytes(fundingData[i].projectId)) ==\n\t\t\t\tkeccak256(bytes(project.name))\n\t\t\t) {\n\t\t\t\treturn\n\t\t\t\t\t(project.totalContributions *\n\t\t\t\t\t\tfundingData[i].fundingPercentage) / 100;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}\n"
    },
    "contracts/JsmnSolLib.sol": {
      "content": "/*\nCopyright (c) 2017 Christoph Niemann\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary JsmnSolLib {\n\tenum JsmnType {\n\t\tUNDEFINED,\n\t\tOBJECT,\n\t\tARRAY,\n\t\tSTRING,\n\t\tPRIMITIVE\n\t}\n\n\tuint constant RETURN_SUCCESS = 0;\n\tuint constant RETURN_ERROR_INVALID_JSON = 1;\n\tuint constant RETURN_ERROR_PART = 2;\n\tuint constant RETURN_ERROR_NO_MEM = 3;\n\n\tstruct Token {\n\t\tJsmnType jsmnType;\n\t\tuint start;\n\t\tbool startSet;\n\t\tuint end;\n\t\tbool endSet;\n\t\tuint8 size;\n\t}\n\n\tstruct Parser {\n\t\tuint pos;\n\t\tuint toknext;\n\t\tint toksuper;\n\t}\n\n\tfunction init(\n\t\tuint length\n\t) internal pure returns (Parser memory, Token[] memory) {\n\t\tParser memory p = Parser(0, 0, -1);\n\t\tToken[] memory t = new Token[](length);\n\t\treturn (p, t);\n\t}\n\n\tfunction allocateToken(\n\t\tParser memory parser,\n\t\tToken[] memory tokens\n\t) internal pure returns (bool, Token memory) {\n\t\tif (parser.toknext >= tokens.length) {\n\t\t\t// no more space in tokens\n\t\t\treturn (false, tokens[tokens.length - 1]);\n\t\t}\n\t\tToken memory token = Token(JsmnType.UNDEFINED, 0, false, 0, false, 0);\n\t\ttokens[parser.toknext] = token;\n\t\tparser.toknext++;\n\t\treturn (true, token);\n\t}\n\n\tfunction fillToken(\n\t\tToken memory token,\n\t\tJsmnType jsmnType,\n\t\tuint start,\n\t\tuint end\n\t) internal pure {\n\t\ttoken.jsmnType = jsmnType;\n\t\ttoken.start = start;\n\t\ttoken.startSet = true;\n\t\ttoken.end = end;\n\t\ttoken.endSet = true;\n\t\ttoken.size = 0;\n\t}\n\n\tfunction parseString(\n\t\tParser memory parser,\n\t\tToken[] memory tokens,\n\t\tbytes memory s\n\t) internal pure returns (uint) {\n\t\tuint start = parser.pos;\n\t\tbool success;\n\t\tToken memory token;\n\t\tparser.pos++;\n\n\t\tfor (; parser.pos < s.length; parser.pos++) {\n\t\t\tbytes1 c = s[parser.pos];\n\n\t\t\t// Quote -> end of string\n\t\t\tif (c == '\"') {\n\t\t\t\t(success, token) = allocateToken(parser, tokens);\n\t\t\t\tif (!success) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn RETURN_ERROR_NO_MEM;\n\t\t\t\t}\n\t\t\t\tfillToken(token, JsmnType.STRING, start + 1, parser.pos);\n\t\t\t\treturn RETURN_SUCCESS;\n\t\t\t}\n\n\t\t\tif (uint8(c) == 92 && parser.pos + 1 < s.length) {\n\t\t\t\t// handle escaped characters: skip over it\n\t\t\t\tparser.pos++;\n\t\t\t\tif (\n\t\t\t\t\ts[parser.pos] == '\"' ||\n\t\t\t\t\ts[parser.pos] == \"/\" ||\n\t\t\t\t\ts[parser.pos] == \"\\\\\" ||\n\t\t\t\t\ts[parser.pos] == \"f\" ||\n\t\t\t\t\ts[parser.pos] == \"r\" ||\n\t\t\t\t\ts[parser.pos] == \"n\" ||\n\t\t\t\t\ts[parser.pos] == \"b\" ||\n\t\t\t\t\ts[parser.pos] == \"t\"\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\t// all other values are INVALID\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn (RETURN_ERROR_INVALID_JSON);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tparser.pos = start;\n\t\treturn RETURN_ERROR_PART;\n\t}\n\n\tfunction parsePrimitive(\n\t\tParser memory parser,\n\t\tToken[] memory tokens,\n\t\tbytes memory s\n\t) internal pure returns (uint) {\n\t\tbool found = false;\n\t\tuint start = parser.pos;\n\t\tbytes1 c;\n\t\tbool success;\n\t\tToken memory token;\n\t\tfor (; parser.pos < s.length; parser.pos++) {\n\t\t\tc = s[parser.pos];\n\t\t\tif (\n\t\t\t\tc == \" \" ||\n\t\t\t\tc == \"\\t\" ||\n\t\t\t\tc == \"\\n\" ||\n\t\t\t\tc == \"\\r\" ||\n\t\t\t\tc == \",\" ||\n\t\t\t\tc == 0x7d ||\n\t\t\t\tc == 0x5d\n\t\t\t) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (uint8(c) < 32 || uint8(c) > 127) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn RETURN_ERROR_INVALID_JSON;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tparser.pos = start;\n\t\t\treturn RETURN_ERROR_PART;\n\t\t}\n\n\t\t// found the end\n\t\t(success, token) = allocateToken(parser, tokens);\n\t\tif (!success) {\n\t\t\tparser.pos = start;\n\t\t\treturn RETURN_ERROR_NO_MEM;\n\t\t}\n\t\tfillToken(token, JsmnType.PRIMITIVE, start, parser.pos);\n\t\tparser.pos--;\n\t\treturn RETURN_SUCCESS;\n\t}\n\n\tfunction parse(\n\t\tstring memory json,\n\t\tuint numberElements\n\t) internal pure returns (uint, Token[] memory tokens, uint) {\n\t\tbytes memory s = bytes(json);\n\t\tbool success;\n\t\tParser memory parser;\n\t\t(parser, tokens) = init(numberElements);\n\n\t\t// Token memory token;\n\t\tuint r;\n\t\tuint count = parser.toknext;\n\t\tuint i;\n\t\tToken memory token;\n\n\t\tfor (; parser.pos < s.length; parser.pos++) {\n\t\t\tbytes1 c = s[parser.pos];\n\n\t\t\t// 0x7b, 0x5b opening curly parentheses or brackets\n\t\t\tif (c == 0x7b || c == 0x5b) {\n\t\t\t\tcount++;\n\t\t\t\t(success, token) = allocateToken(parser, tokens);\n\t\t\t\tif (!success) {\n\t\t\t\t\treturn (RETURN_ERROR_NO_MEM, tokens, 0);\n\t\t\t\t}\n\t\t\t\tif (parser.toksuper != -1) {\n\t\t\t\t\ttokens[uint(parser.toksuper)].size++;\n\t\t\t\t}\n\t\t\t\ttoken.jsmnType = (c == 0x7b ? JsmnType.OBJECT : JsmnType.ARRAY);\n\t\t\t\ttoken.start = parser.pos;\n\t\t\t\ttoken.startSet = true;\n\t\t\t\tparser.toksuper = int(parser.toknext - 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// closing curly parentheses or brackets\n\t\t\tif (c == 0x7d || c == 0x5d) {\n\t\t\t\tJsmnType tokenType = (\n\t\t\t\t\tc == 0x7d ? JsmnType.OBJECT : JsmnType.ARRAY\n\t\t\t\t);\n\t\t\t\tbool isUpdated = false;\n\t\t\t\tfor (i = parser.toknext - 1; i >= 0; i--) {\n\t\t\t\t\ttoken = tokens[i];\n\t\t\t\t\tif (token.startSet && !token.endSet) {\n\t\t\t\t\t\tif (token.jsmnType != tokenType) {\n\t\t\t\t\t\t\t// found a token that hasn't been closed but from a different type\n\t\t\t\t\t\t\treturn (RETURN_ERROR_INVALID_JSON, tokens, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.toksuper = -1;\n\t\t\t\t\t\ttokens[i].end = parser.pos + 1;\n\t\t\t\t\t\ttokens[i].endSet = true;\n\t\t\t\t\t\tisUpdated = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isUpdated) {\n\t\t\t\t\treturn (RETURN_ERROR_INVALID_JSON, tokens, 0);\n\t\t\t\t}\n\t\t\t\tfor (; i > 0; i--) {\n\t\t\t\t\ttoken = tokens[i];\n\t\t\t\t\tif (token.startSet && !token.endSet) {\n\t\t\t\t\t\tparser.toksuper = int(i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (i == 0) {\n\t\t\t\t\ttoken = tokens[i];\n\t\t\t\t\tif (token.startSet && !token.endSet) {\n\t\t\t\t\t\tparser.toksuper = int(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// 0x42\n\t\t\tif (c == '\"') {\n\t\t\t\tr = parseString(parser, tokens, s);\n\n\t\t\t\tif (r != RETURN_SUCCESS) {\n\t\t\t\t\treturn (r, tokens, 0);\n\t\t\t\t}\n\t\t\t\t//JsmnError.INVALID;\n\t\t\t\tcount++;\n\t\t\t\tif (parser.toksuper != -1) tokens[uint(parser.toksuper)].size++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// ' ', \\r, \\t, \\n\n\t\t\tif (c == \" \" || c == 0x11 || c == 0x12 || c == 0x14) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// 0x3a\n\t\t\tif (c == \":\") {\n\t\t\t\tparser.toksuper = int(parser.toknext - 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c == \",\") {\n\t\t\t\tif (\n\t\t\t\t\tparser.toksuper != -1 &&\n\t\t\t\t\ttokens[uint(parser.toksuper)].jsmnType != JsmnType.ARRAY &&\n\t\t\t\t\ttokens[uint(parser.toksuper)].jsmnType != JsmnType.OBJECT\n\t\t\t\t) {\n\t\t\t\t\tfor (i = parser.toknext - 1; i >= 0; i--) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttokens[i].jsmnType == JsmnType.ARRAY ||\n\t\t\t\t\t\t\ttokens[i].jsmnType == JsmnType.OBJECT\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif (tokens[i].startSet && !tokens[i].endSet) {\n\t\t\t\t\t\t\t\tparser.toksuper = int(i);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Primitive\n\t\t\tif (\n\t\t\t\t(c >= \"0\" && c <= \"9\") ||\n\t\t\t\tc == \"-\" ||\n\t\t\t\tc == \"f\" ||\n\t\t\t\tc == \"t\" ||\n\t\t\t\tc == \"n\"\n\t\t\t) {\n\t\t\t\tif (parser.toksuper != -1) {\n\t\t\t\t\ttoken = tokens[uint(parser.toksuper)];\n\t\t\t\t\tif (\n\t\t\t\t\t\ttoken.jsmnType == JsmnType.OBJECT ||\n\t\t\t\t\t\t(token.jsmnType == JsmnType.STRING && token.size != 0)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn (RETURN_ERROR_INVALID_JSON, tokens, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tr = parsePrimitive(parser, tokens, s);\n\t\t\t\tif (r != RETURN_SUCCESS) {\n\t\t\t\t\treturn (r, tokens, 0);\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t\tif (parser.toksuper != -1) {\n\t\t\t\t\ttokens[uint(parser.toksuper)].size++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// printable char\n\t\t\tif (c >= 0x20 && c <= 0x7e) {\n\t\t\t\treturn (RETURN_ERROR_INVALID_JSON, tokens, 0);\n\t\t\t}\n\t\t}\n\n\t\treturn (RETURN_SUCCESS, tokens, parser.toknext);\n\t}\n\n\tfunction getBytes(\n\t\tstring memory json,\n\t\tuint start,\n\t\tuint end\n\t) internal pure returns (string memory) {\n\t\tbytes memory s = bytes(json);\n\t\tbytes memory result = new bytes(end - start);\n\t\tfor (uint i = start; i < end; i++) {\n\t\t\tresult[i - start] = s[i];\n\t\t}\n\t\treturn string(result);\n\t}\n\n\t// parseInt\n\tfunction parseInt(string memory _a) internal pure returns (int) {\n\t\treturn parseInt(_a, 0);\n\t}\n\n\t// parseInt(parseFloat*10^_b)\n\tfunction parseInt(string memory _a, uint _b) internal pure returns (int) {\n\t\tbytes memory bresult = bytes(_a);\n\t\tint mint = 0;\n\t\tbool decimals = false;\n\t\tbool negative = false;\n\t\tfor (uint i = 0; i < bresult.length; i++) {\n\t\t\tif ((i == 0) && (bresult[i] == \"-\")) {\n\t\t\t\tnegative = true;\n\t\t\t}\n\t\t\tif ((uint8(bresult[i]) >= 48) && (uint8(bresult[i]) <= 57)) {\n\t\t\t\tif (decimals) {\n\t\t\t\t\tif (_b == 0) break;\n\t\t\t\t\telse _b--;\n\t\t\t\t}\n\t\t\t\tmint *= 10;\n\t\t\t\tmint += int(uint256(uint8(bresult[i]))) - 48;\n\t\t\t} else if (uint8(bresult[i]) == 46) decimals = true;\n\t\t}\n\t\tif (_b > 0) mint *= int(10 ** _b);\n\t\tif (negative) mint *= -1;\n\t\treturn mint;\n\t}\n\n\tfunction uint2str(uint i) internal pure returns (string memory) {\n\t\tif (i == 0) return \"0\";\n\t\tuint j = i;\n\t\tuint len;\n\t\twhile (j != 0) {\n\t\t\tlen++;\n\t\t\tj /= 10;\n\t\t}\n\t\tbytes memory bstr = new bytes(len);\n\t\tuint k = len - 1;\n\t\twhile (i != 0) {\n\t\t\tbstr[k--] = bytes1(uint8(48 + (i % 10)));\n\t\t\ti /= 10;\n\t\t}\n\t\treturn string(bstr);\n\t}\n\n\tfunction parseBool(string memory _a) internal pure returns (bool) {\n\t\tif (strCompare(_a, \"true\") == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction strCompare(\n\t\tstring memory _a,\n\t\tstring memory _b\n\t) internal pure returns (int) {\n\t\tbytes memory a = bytes(_a);\n\t\tbytes memory b = bytes(_b);\n\t\tuint minLength = a.length;\n\t\tif (b.length < minLength) minLength = b.length;\n\t\tfor (uint i = 0; i < minLength; i++)\n\t\t\tif (a[i] < b[i]) return -1;\n\t\t\telse if (a[i] > b[i]) return 1;\n\t\tif (a.length < b.length) return -1;\n\t\telse if (a.length > b.length) return 1;\n\t\telse return 0;\n\t}\n}\n"
    },
    "interfaces/IGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IGateway {\n\tstruct ExecutionInfo {\n\t\tbytes user_key;\n\t\tbytes user_pubkey;\n\t\tstring routing_code_hash;\n\t\tstring task_destination_network;\n\t\tstring handle;\n\t\tbytes12 nonce;\n\t\tuint32 callback_gas_limit;\n\t\tbytes payload;\n\t\tbytes payload_signature;\n\t}\n\n\tfunction send(\n\t\tbytes32 _payloadHash,\n\t\taddress _userAddress,\n\t\tstring calldata _routingInfo,\n\t\tExecutionInfo calldata _info\n\t) external payable;\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}