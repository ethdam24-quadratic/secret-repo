{
  "language": "Solidity",
  "sources": {
    "abdk-libraries-solidity/ABDKMath64x64.sol": {
      "content": "// SPDX-License-Identifier: BSD-4-Clause\n/*\n * ABDK Math 64.64 Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity ^0.8.0;\n\n/**\n * Smart contract library of mathematical functions operating with signed\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\n * basically a simple fraction whose numerator is signed 128-bit integer and\n * denominator is 2^64.  As long as denominator is always the same, there is no\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\n * represented by int128 type holding only the numerator.\n */\nlibrary ABDKMath64x64 {\n  /*\n   * Minimum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n\n  /*\n   * Maximum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  /**\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromInt (int256 x) internal pure returns (int128) {\n    unchecked {\n      require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\n      return int128 (x << 64);\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\n   * rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64-bit integer number\n   */\n  function toInt (int128 x) internal pure returns (int64) {\n    unchecked {\n      return int64 (x >> 64);\n    }\n  }\n\n  /**\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromUInt (uint256 x) internal pure returns (int128) {\n    unchecked {\n      require (x <= 0x7FFFFFFFFFFFFFFF);\n      return int128 (int256 (x << 64));\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\n   * number rounding down.  Revert on underflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return unsigned 64-bit integer number\n   */\n  function toUInt (int128 x) internal pure returns (uint64) {\n    unchecked {\n      require (x >= 0);\n      return uint64 (uint128 (x >> 64));\n    }\n  }\n\n  /**\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\n   * number rounding down.  Revert on overflow.\n   *\n   * @param x signed 128.128-bin fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function from128x128 (int256 x) internal pure returns (int128) {\n    unchecked {\n      int256 result = x >> 64;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\n   * number.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 128.128 fixed point number\n   */\n  function to128x128 (int128 x) internal pure returns (int256) {\n    unchecked {\n      return int256 (x) << 64;\n    }\n  }\n\n  /**\n   * Calculate x + y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function add (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) + y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x - y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sub (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) - y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function mul (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) * y >> 64;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\n   * number and y is signed 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y signed 256-bit integer number\n   * @return signed 256-bit integer number\n   */\n  function muli (int128 x, int256 y) internal pure returns (int256) {\n    unchecked {\n      if (x == MIN_64x64) {\n        require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\n          y <= 0x1000000000000000000000000000000000000000000000000);\n        return -y << 63;\n      } else {\n        bool negativeResult = false;\n        if (x < 0) {\n          x = -x;\n          negativeResult = true;\n        }\n        if (y < 0) {\n          y = -y; // We rely on overflow behavior here\n          negativeResult = !negativeResult;\n        }\n        uint256 absoluteResult = mulu (x, uint256 (y));\n        if (negativeResult) {\n          require (absoluteResult <=\n            0x8000000000000000000000000000000000000000000000000000000000000000);\n          return -int256 (absoluteResult); // We rely on overflow behavior here\n        } else {\n          require (absoluteResult <=\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n          return int256 (absoluteResult);\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 256-bit integer number\n   */\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\n    unchecked {\n      if (y == 0) return 0;\n\n      require (x >= 0);\n\n      uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\n      uint256 hi = uint256 (int256 (x)) * (y >> 128);\n\n      require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      hi <<= 64;\n\n      require (hi <=\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\n      return hi + lo;\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function div (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n      int256 result = (int256 (x) << 64) / y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x signed 256-bit integer number\n   * @param y signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divi (int256 x, int256 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n\n      bool negativeResult = false;\n      if (x < 0) {\n        x = -x; // We rely on overflow behavior here\n        negativeResult = true;\n      }\n      if (y < 0) {\n        y = -y; // We rely on overflow behavior here\n        negativeResult = !negativeResult;\n      }\n      uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\n      if (negativeResult) {\n        require (absoluteResult <= 0x80000000000000000000000000000000);\n        return -int128 (absoluteResult); // We rely on overflow behavior here\n      } else {\n        require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int128 (absoluteResult); // We rely on overflow behavior here\n      }\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n      uint128 result = divuu (x, y);\n      require (result <= uint128 (MAX_64x64));\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate -x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function neg (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != MIN_64x64);\n      return -x;\n    }\n  }\n\n  /**\n   * Calculate |x|.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function abs (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != MIN_64x64);\n      return x < 0 ? -x : x;\n    }\n  }\n\n  /**\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function inv (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != 0);\n      int256 result = int256 (0x100000000000000000000000000000000) / x;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function avg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      return int128 ((int256 (x) + int256 (y)) >> 1);\n    }\n  }\n\n  /**\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\n   * Revert on overflow or in case x * y is negative.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 m = int256 (x) * int256 (y);\n      require (m >= 0);\n      require (m <\n          0x4000000000000000000000000000000000000000000000000000000000000000);\n      return int128 (sqrtu (uint256 (m)));\n    }\n  }\n\n  /**\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y uint256 value\n   * @return signed 64.64-bit fixed point number\n   */\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n      bool negative = x < 0 && y & 1 == 1;\n\n      uint256 absX = uint128 (x < 0 ? -x : x);\n      uint256 absResult;\n      absResult = 0x100000000000000000000000000000000;\n\n      if (absX <= 0x10000000000000000) {\n        absX <<= 63;\n        while (y != 0) {\n          if (y & 0x1 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x2 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x4 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x8 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          y >>= 4;\n        }\n\n        absResult >>= 64;\n      } else {\n        uint256 absXShift = 63;\n        if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\n        if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\n        if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\n        if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\n        if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\n        if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\n\n        uint256 resultShift = 0;\n        while (y != 0) {\n          require (absXShift < 64);\n\n          if (y & 0x1 != 0) {\n            absResult = absResult * absX >> 127;\n            resultShift += absXShift;\n            if (absResult > 0x100000000000000000000000000000000) {\n              absResult >>= 1;\n              resultShift += 1;\n            }\n          }\n          absX = absX * absX >> 127;\n          absXShift <<= 1;\n          if (absX >= 0x100000000000000000000000000000000) {\n              absX >>= 1;\n              absXShift += 1;\n          }\n\n          y >>= 1;\n        }\n\n        require (resultShift < 64);\n        absResult >>= 64 - resultShift;\n      }\n      int256 result = negative ? -int256 (absResult) : int256 (absResult);\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sqrt (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x >= 0);\n      return int128 (sqrtu (uint256 (int256 (x)) << 64));\n    }\n  }\n\n  /**\n   * Calculate binary logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function log_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x > 0);\n\n      int256 msb = 0;\n      int256 xc = x;\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n      int256 result = msb - 64 << 64;\n      uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);\n      for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n        ux *= ux;\n        uint256 b = ux >> 255;\n        ux >>= 127 + b;\n        result += bit * int256 (b);\n      }\n\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate natural logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function ln (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x > 0);\n\n      return int128 (int256 (\n          uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\n    }\n  }\n\n  /**\n   * Calculate binary exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x < 0x400000000000000000); // Overflow\n\n      if (x < -0x400000000000000000) return 0; // Underflow\n\n      uint256 result = 0x80000000000000000000000000000000;\n\n      if (x & 0x8000000000000000 > 0)\n        result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n      if (x & 0x4000000000000000 > 0)\n        result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n      if (x & 0x2000000000000000 > 0)\n        result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n      if (x & 0x1000000000000000 > 0)\n        result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n      if (x & 0x800000000000000 > 0)\n        result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n      if (x & 0x400000000000000 > 0)\n        result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n      if (x & 0x200000000000000 > 0)\n        result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n      if (x & 0x100000000000000 > 0)\n        result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n      if (x & 0x80000000000000 > 0)\n        result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n      if (x & 0x40000000000000 > 0)\n        result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n      if (x & 0x20000000000000 > 0)\n        result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n      if (x & 0x10000000000000 > 0)\n        result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n      if (x & 0x8000000000000 > 0)\n        result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n      if (x & 0x4000000000000 > 0)\n        result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n      if (x & 0x2000000000000 > 0)\n        result = result * 0x1000162E525EE054754457D5995292026 >> 128;\n      if (x & 0x1000000000000 > 0)\n        result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n      if (x & 0x800000000000 > 0)\n        result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n      if (x & 0x400000000000 > 0)\n        result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n      if (x & 0x200000000000 > 0)\n        result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n      if (x & 0x100000000000 > 0)\n        result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n      if (x & 0x80000000000 > 0)\n        result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n      if (x & 0x40000000000 > 0)\n        result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n      if (x & 0x20000000000 > 0)\n        result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n      if (x & 0x10000000000 > 0)\n        result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n      if (x & 0x8000000000 > 0)\n        result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n      if (x & 0x4000000000 > 0)\n        result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n      if (x & 0x2000000000 > 0)\n        result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n      if (x & 0x1000000000 > 0)\n        result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n      if (x & 0x800000000 > 0)\n        result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n      if (x & 0x400000000 > 0)\n        result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n      if (x & 0x200000000 > 0)\n        result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n      if (x & 0x100000000 > 0)\n        result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n      if (x & 0x80000000 > 0)\n        result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n      if (x & 0x40000000 > 0)\n        result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n      if (x & 0x20000000 > 0)\n        result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n      if (x & 0x10000000 > 0)\n        result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n      if (x & 0x8000000 > 0)\n        result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n      if (x & 0x4000000 > 0)\n        result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n      if (x & 0x2000000 > 0)\n        result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n      if (x & 0x1000000 > 0)\n        result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n      if (x & 0x800000 > 0)\n        result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n      if (x & 0x400000 > 0)\n        result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\n      if (x & 0x200000 > 0)\n        result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\n      if (x & 0x100000 > 0)\n        result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\n      if (x & 0x80000 > 0)\n        result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n      if (x & 0x40000 > 0)\n        result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n      if (x & 0x20000 > 0)\n        result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n      if (x & 0x10000 > 0)\n        result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n      if (x & 0x8000 > 0)\n        result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n      if (x & 0x4000 > 0)\n        result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n      if (x & 0x2000 > 0)\n        result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\n      if (x & 0x1000 > 0)\n        result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n      if (x & 0x800 > 0)\n        result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n      if (x & 0x400 > 0)\n        result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\n      if (x & 0x200 > 0)\n        result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n      if (x & 0x100 > 0)\n        result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\n      if (x & 0x80 > 0)\n        result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n      if (x & 0x40 > 0)\n        result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n      if (x & 0x20 > 0)\n        result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\n      if (x & 0x10 > 0)\n        result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n      if (x & 0x8 > 0)\n        result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n      if (x & 0x4 > 0)\n        result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n      if (x & 0x2 > 0)\n        result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\n      if (x & 0x1 > 0)\n        result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\n\n      result >>= uint256 (int256 (63 - (x >> 64)));\n      require (result <= uint256 (int256 (MAX_64x64)));\n\n      return int128 (int256 (result));\n    }\n  }\n\n  /**\n   * Calculate natural exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x < 0x400000000000000000); // Overflow\n\n      if (x < -0x400000000000000000) return 0; // Underflow\n\n      return exp_2 (\n          int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 64.64-bit fixed point number\n   */\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\n    unchecked {\n      require (y != 0);\n\n      uint256 result;\n\n      if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        result = (x << 64) / y;\n      else {\n        uint256 msb = 192;\n        uint256 xc = x >> 192;\n        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n        if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n        if (xc >= 0x100) { xc >>= 8; msb += 8; }\n        if (xc >= 0x10) { xc >>= 4; msb += 4; }\n        if (xc >= 0x4) { xc >>= 2; msb += 2; }\n        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n        result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\n        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        uint256 hi = result * (y >> 128);\n        uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        uint256 xh = x >> 192;\n        uint256 xl = x << 64;\n\n        if (xl < lo) xh -= 1;\n        xl -= lo; // We rely on overflow behavior here\n        lo = hi << 128;\n        if (xl < lo) xh -= 1;\n        xl -= lo; // We rely on overflow behavior here\n\n        result += xh == hi >> 128 ? xl / y : 1;\n      }\n\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      return uint128 (result);\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\n   * number.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return unsigned 128-bit integer number\n   */\n  function sqrtu (uint256 x) private pure returns (uint128) {\n    unchecked {\n      if (x == 0) return 0;\n      else {\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\n        if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\n        if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\n        if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\n        if (xx >= 0x100) { xx >>= 8; r <<= 4; }\n        if (xx >= 0x10) { xx >>= 4; r <<= 2; }\n        if (xx >= 0x4) { r <<= 1; }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return uint128 (r < r1 ? r : r1);\n      }\n    }\n  }\n}\n"
    },
    "contracts/Funding.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\nimport \"abdk-libraries-solidity/ABDKMath64x64.sol\";\nimport \"../interfaces/IGateway.sol\";\nimport \"./JsmnSolLib.sol\";\n\n/**\n * A smart contract for cross-chain quadratic voting developed during EthDam 24.\n * This contract supports various types of funding curves and ensures privacy and security through integration with the Secret Network.\n * @author arjanjohan\n */\ncontract Funding {\n\t// ========================================\n\t//     ENUM, STRUCTS AND MAPPINGS\n\t// ========================================\n\n\tstruct Project {\n\t\tuint256 id;\n\t\tstring name;\n\t\tstring description;\n\t\taddress payable projectAddress;\n\t\tuint256 totalContributions;\n\t\tuint256 totalSquareRoots;\n\t}\n\n\tstruct FundingRound {\n\t\tuint256 id;\n\t\tstring name;\n\t\tstring description;\n\t\tstring curveType;\n\t\tmapping(uint256 => Project) projects;\n\t\tuint256[] projectIds;\n\t\tuint256 totalContributions;\n\t\tbool isOpen;\n\t}\n\n\tmapping(uint256 => FundingRound) public fundingRounds;\n\tuint256[] public roundIds;\n\n\t// ========================================\n\t//     CONSTRUCTOR AND VALUES\n\t// ========================================\n\n\tIGateway public gatewayContract;\n\taddress public gatewayAddressSepolia =\n\t\taddress(0x3879E146140b627a5C858a08e507B171D9E43139);\n\n\tconstructor() {\n\t\tgatewayContract = IGateway(gatewayAddressSepolia);\n\t}\n\n\t// ========================================\n\t//     EVENTS\n\t// ========================================\n\tevent RoundCreated(\n\t\tuint256 indexed roundId,\n\t\tstring name,\n\t\tuint256[] projectIds\n\t);\n\n\tevent RoundCreatedInSecret(\n\t\tuint256 indexed roundId,\n\t\tstring name,\n\t\tuint256[] projectIds\n\t);\n\n\tevent ContributionReceived(address indexed contributor);\n\n\tevent ContributionReceivedInSecret(\n\t\taddress indexed contributor,\n\t\tuint256 indexed roundId\n\t);\n\n\tevent RoundClosed(uint256 indexed roundId);\n\n\tevent RoundClosedInSecret(uint256 indexed roundId);\n\n\t// ========================================\n\t//     CORE FUNCTIONS\n\t// ========================================\n\n\tfunction createFundingRound(\n\t\tuint256 id,\n\t\tstring memory name,\n\t\tstring memory description,\n\t\tstring memory curveType,\n\t\tuint256[] memory projectIds,\n\t\tstring[] memory projectNames,\n\t\tstring[] memory projectDescriptions,\n\t\taddress payable[] memory projectAddresses,\n\t\tbool sendToSecret,\n\t\tbytes32 payloadHash,\n\t\tstring calldata routingInfo,\n\t\tIGateway.ExecutionInfo calldata info\n\t) public payable {\n\t\tvalidateProjectParameters(\n\t\t\tprojectIds,\n\t\t\tprojectNames,\n\t\t\tprojectDescriptions,\n\t\t\tprojectAddresses\n\t\t);\n\t\trequire(fundingRounds[id].id == 0, \"Round ID exists\");\n\n\t\tif (sendToSecret) {\n\t\t\tgatewayContract.send{ value: msg.value }(\n\t\t\t\tpayloadHash,\n\t\t\t\tmsg.sender,\n\t\t\t\troutingInfo,\n\t\t\t\tinfo\n\t\t\t);\n\t\t}\n\n\t\tFundingRound storage round = fundingRounds[id];\n\t\tsetupFundingRound(\n\t\t\tround,\n\t\t\tid,\n\t\t\tname,\n\t\t\tdescription,\n\t\t\tcurveType,\n\t\t\tprojectIds,\n\t\t\tprojectNames,\n\t\t\tprojectDescriptions,\n\t\t\tprojectAddresses\n\t\t);\n\t\troundIds.push(id);\n\t\temit RoundCreated(id, name, projectIds);\n\t}\n\n\t// callback function for secret\n\tfunction createdFundingRound(\n\t\tuint256 id,\n\t\tstring memory name,\n\t\tuint256[] memory projectIds\n\t) public {\n\t\temit RoundCreatedInSecret(id, name, projectIds);\n\t}\n\n\tfunction contribute(\n\t\tbytes32 payloadHash,\n\t\tstring calldata routingInfo,\n\t\tIGateway.ExecutionInfo calldata info\n\t) public payable {\n\t\tgatewayContract.send{ value: msg.value }( // todo change this value\n\t\t\tpayloadHash,\n\t\t\tmsg.sender,\n\t\t\troutingInfo,\n\t\t\tinfo\n\t\t);\n\t\temit ContributionReceived(msg.sender);\n\t}\n\n\t// callback function for secret\n\tfunction contribute(uint256 roundId) public {\n\t\temit ContributionReceivedInSecret(msg.sender, roundId);\n\t}\n\n\tfunction closeFundingRound(\n\t\tuint256 roundId,\n\t\tbool sendToSecret,\n\t\tbytes32 payloadHash,\n\t\tstring calldata routingInfo,\n\t\tIGateway.ExecutionInfo calldata info\n\t) public payable {\n\t\trequire(fundingRounds[roundId].isOpen, \"Round closed\");\n\t\tfundingRounds[roundId].isOpen = false;\n\n\t\tstring memory json = \"\"; // todo update this from secret\n\t\tif (sendToSecret) {\n\t\t\tgatewayContract.send{ value: msg.value }(\n\t\t\t\tpayloadHash,\n\t\t\t\tmsg.sender,\n\t\t\t\troutingInfo,\n\t\t\t\tinfo\n\t\t\t);\n\t\t} else {\n\t\t\t// Different function to retrieve results\n\t\t}\n\t\tdistributeFunds(json, roundId);\n\t\temit RoundClosed(roundId);\n\t}\n\n\t// callback function for secret\n\tfunction closedFundingRound(uint256 roundId) public {\n\t\temit RoundClosedInSecret(roundId);\n\t}\n\n\t// ========================================\n\t//     HELPER FUNCTIONS\n\t// ========================================\n\n\tfunction validateProjectParameters(\n\t\tuint256[] memory projectIds,\n\t\tstring[] memory projectNames,\n\t\tstring[] memory projectDescriptions,\n\t\taddress payable[] memory projectAddresses\n\t) private pure {\n\t\trequire(\n\t\t\tprojectIds.length == projectNames.length &&\n\t\t\t\tprojectNames.length == projectDescriptions.length &&\n\t\t\t\tprojectDescriptions.length == projectAddresses.length,\n\t\t\t\"Mismatched input arrays\"\n\t\t);\n\t}\n\n\tfunction setupFundingRound(\n\t\tFundingRound storage round,\n\t\tuint256 id,\n\t\tstring memory name,\n\t\tstring memory description,\n\t\tstring memory curveType,\n\t\tuint256[] memory projectIds,\n\t\tstring[] memory projectNames,\n\t\tstring[] memory projectDescriptions,\n\t\taddress payable[] memory projectAddresses\n\t) private {\n\t\tround.id = id;\n\t\tround.name = name;\n\t\tround.description = description;\n\t\tround.curveType = curveType;\n\t\tround.isOpen = true;\n\n\t\tfor (uint256 i = 0; i < projectIds.length; i++) {\n\t\t\trequire(round.projects[projectIds[i]].id == 0, \"Project ID exists\");\n\t\t\tround.projects[projectIds[i]] = Project({\n\t\t\t\tid: projectIds[i],\n\t\t\t\tname: projectNames[i],\n\t\t\t\tdescription: projectDescriptions[i],\n\t\t\t\tprojectAddress: projectAddresses[i],\n\t\t\t\ttotalContributions: 0,\n\t\t\t\ttotalSquareRoots: 0\n\t\t\t});\n\t\t\tround.projectIds.push(projectIds[i]);\n\t\t}\n\t}\n\n\tfunction validRound(uint256 roundId) private view returns (bool) {\n\t\treturn fundingRounds[roundId].isOpen && fundingRounds[roundId].id != 0;\n\t}\n\n\tfunction processContributions(\n\t\tuint256 roundId,\n\t\tuint256[] memory projectIds,\n\t\tuint256[] memory amounts\n\t) private view returns (uint256 totalContributed) {\n\t\tfor (uint256 i = 0; i < amounts.length; i++) {\n\t\t\tProject storage project = fundingRounds[roundId].projects[\n\t\t\t\tprojectIds[i]\n\t\t\t];\n\t\t\trequire(project.id != 0, \"Project not found\");\n\t\t\ttotalContributed += amounts[i];\n\t\t}\n\t}\n\n\tfunction distributeFunds(string memory json, uint256 roundId) public {\n\t\t// Parse the JSON input\n\t\tuint256 numTokens;\n\t\tJsmnSolLib.Token[] memory tokens;\n\t\t(, tokens, numTokens) = JsmnSolLib.parse(json, 20);\n\n\t\t// Ensure JSON parsing succeeded\n\t\trequire(numTokens > 0, \"JSON parsing failed or no data found\");\n\n\t\tuint256 totalFunds = fundingRounds[roundId].totalContributions;\n\n\t\t// Iterate over each project in the round\n\t\tfor (uint256 i = 0; i < fundingRounds[roundId].projectIds.length; i++) {\n\t\t\tProject storage project = fundingRounds[roundId].projects[\n\t\t\t\tfundingRounds[roundId].projectIds[i]\n\t\t\t];\n\n\t\t\t// Find matching project ID in JSON and calculate the payout\n\t\t\tuint256 payout = 0;\n\t\t\tfor (uint256 j = 1; j < numTokens - 1; j += 3) {\n\t\t\t\t// Using getBytes to extract the project id from json\n\t\t\t\tstring memory projectId = JsmnSolLib.getBytes(\n\t\t\t\t\tjson,\n\t\t\t\t\ttokens[j].start,\n\t\t\t\t\ttokens[j].end\n\t\t\t\t);\n\t\t\t\tif (\n\t\t\t\t\tkeccak256(bytes(projectId)) ==\n\t\t\t\t\tkeccak256(bytes(project.name))\n\t\t\t\t) {\n\t\t\t\t\t// Calculate payout based on the funding percentage extracted using getBytes\n\t\t\t\t\tstring memory fundingStr = JsmnSolLib.getBytes(\n\t\t\t\t\t\tjson,\n\t\t\t\t\t\ttokens[j + 1].start,\n\t\t\t\t\t\ttokens[j + 1].end\n\t\t\t\t\t);\n\t\t\t\t\tuint256 fundingPercentage = uint256(\n\t\t\t\t\t\tJsmnSolLib.parseInt(fundingStr)\n\t\t\t\t\t);\n\t\t\t\t\tpayout =\n\t\t\t\t\t\t(project.totalContributions * fundingPercentage) /\n\t\t\t\t\t\t100;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Transfer payout to project address and decrement total funds\n\t\t\tproject.projectAddress.transfer(payout);\n\t\t\ttotalFunds -= payout;\n\t\t}\n\t}\n}\n"
    },
    "contracts/JsmnSolLib.sol": {
      "content": "/*\nCopyright (c) 2017 Christoph Niemann\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary JsmnSolLib {\n\tenum JsmnType {\n\t\tUNDEFINED,\n\t\tOBJECT,\n\t\tARRAY,\n\t\tSTRING,\n\t\tPRIMITIVE\n\t}\n\n\tuint constant RETURN_SUCCESS = 0;\n\tuint constant RETURN_ERROR_INVALID_JSON = 1;\n\tuint constant RETURN_ERROR_PART = 2;\n\tuint constant RETURN_ERROR_NO_MEM = 3;\n\n\tstruct Token {\n\t\tJsmnType jsmnType;\n\t\tuint start;\n\t\tbool startSet;\n\t\tuint end;\n\t\tbool endSet;\n\t\tuint8 size;\n\t}\n\n\tstruct Parser {\n\t\tuint pos;\n\t\tuint toknext;\n\t\tint toksuper;\n\t}\n\n\tfunction init(\n\t\tuint length\n\t) internal pure returns (Parser memory, Token[] memory) {\n\t\tParser memory p = Parser(0, 0, -1);\n\t\tToken[] memory t = new Token[](length);\n\t\treturn (p, t);\n\t}\n\n\tfunction allocateToken(\n\t\tParser memory parser,\n\t\tToken[] memory tokens\n\t) internal pure returns (bool, Token memory) {\n\t\tif (parser.toknext >= tokens.length) {\n\t\t\t// no more space in tokens\n\t\t\treturn (false, tokens[tokens.length - 1]);\n\t\t}\n\t\tToken memory token = Token(JsmnType.UNDEFINED, 0, false, 0, false, 0);\n\t\ttokens[parser.toknext] = token;\n\t\tparser.toknext++;\n\t\treturn (true, token);\n\t}\n\n\tfunction fillToken(\n\t\tToken memory token,\n\t\tJsmnType jsmnType,\n\t\tuint start,\n\t\tuint end\n\t) internal pure {\n\t\ttoken.jsmnType = jsmnType;\n\t\ttoken.start = start;\n\t\ttoken.startSet = true;\n\t\ttoken.end = end;\n\t\ttoken.endSet = true;\n\t\ttoken.size = 0;\n\t}\n\n\tfunction parseString(\n\t\tParser memory parser,\n\t\tToken[] memory tokens,\n\t\tbytes memory s\n\t) internal pure returns (uint) {\n\t\tuint start = parser.pos;\n\t\tbool success;\n\t\tToken memory token;\n\t\tparser.pos++;\n\n\t\tfor (; parser.pos < s.length; parser.pos++) {\n\t\t\tbytes1 c = s[parser.pos];\n\n\t\t\t// Quote -> end of string\n\t\t\tif (c == '\"') {\n\t\t\t\t(success, token) = allocateToken(parser, tokens);\n\t\t\t\tif (!success) {\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn RETURN_ERROR_NO_MEM;\n\t\t\t\t}\n\t\t\t\tfillToken(token, JsmnType.STRING, start + 1, parser.pos);\n\t\t\t\treturn RETURN_SUCCESS;\n\t\t\t}\n\n\t\t\tif (uint8(c) == 92 && parser.pos + 1 < s.length) {\n\t\t\t\t// handle escaped characters: skip over it\n\t\t\t\tparser.pos++;\n\t\t\t\tif (\n\t\t\t\t\ts[parser.pos] == '\"' ||\n\t\t\t\t\ts[parser.pos] == \"/\" ||\n\t\t\t\t\ts[parser.pos] == \"\\\\\" ||\n\t\t\t\t\ts[parser.pos] == \"f\" ||\n\t\t\t\t\ts[parser.pos] == \"r\" ||\n\t\t\t\t\ts[parser.pos] == \"n\" ||\n\t\t\t\t\ts[parser.pos] == \"b\" ||\n\t\t\t\t\ts[parser.pos] == \"t\"\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\t// all other values are INVALID\n\t\t\t\t\tparser.pos = start;\n\t\t\t\t\treturn (RETURN_ERROR_INVALID_JSON);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tparser.pos = start;\n\t\treturn RETURN_ERROR_PART;\n\t}\n\n\tfunction parsePrimitive(\n\t\tParser memory parser,\n\t\tToken[] memory tokens,\n\t\tbytes memory s\n\t) internal pure returns (uint) {\n\t\tbool found = false;\n\t\tuint start = parser.pos;\n\t\tbytes1 c;\n\t\tbool success;\n\t\tToken memory token;\n\t\tfor (; parser.pos < s.length; parser.pos++) {\n\t\t\tc = s[parser.pos];\n\t\t\tif (\n\t\t\t\tc == \" \" ||\n\t\t\t\tc == \"\\t\" ||\n\t\t\t\tc == \"\\n\" ||\n\t\t\t\tc == \"\\r\" ||\n\t\t\t\tc == \",\" ||\n\t\t\t\tc == 0x7d ||\n\t\t\t\tc == 0x5d\n\t\t\t) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (uint8(c) < 32 || uint8(c) > 127) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn RETURN_ERROR_INVALID_JSON;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tparser.pos = start;\n\t\t\treturn RETURN_ERROR_PART;\n\t\t}\n\n\t\t// found the end\n\t\t(success, token) = allocateToken(parser, tokens);\n\t\tif (!success) {\n\t\t\tparser.pos = start;\n\t\t\treturn RETURN_ERROR_NO_MEM;\n\t\t}\n\t\tfillToken(token, JsmnType.PRIMITIVE, start, parser.pos);\n\t\tparser.pos--;\n\t\treturn RETURN_SUCCESS;\n\t}\n\n\tfunction parse(\n\t\tstring memory json,\n\t\tuint numberElements\n\t) internal pure returns (uint, Token[] memory tokens, uint) {\n\t\tbytes memory s = bytes(json);\n\t\tbool success;\n\t\tParser memory parser;\n\t\t(parser, tokens) = init(numberElements);\n\n\t\t// Token memory token;\n\t\tuint r;\n\t\tuint count = parser.toknext;\n\t\tuint i;\n\t\tToken memory token;\n\n\t\tfor (; parser.pos < s.length; parser.pos++) {\n\t\t\tbytes1 c = s[parser.pos];\n\n\t\t\t// 0x7b, 0x5b opening curly parentheses or brackets\n\t\t\tif (c == 0x7b || c == 0x5b) {\n\t\t\t\tcount++;\n\t\t\t\t(success, token) = allocateToken(parser, tokens);\n\t\t\t\tif (!success) {\n\t\t\t\t\treturn (RETURN_ERROR_NO_MEM, tokens, 0);\n\t\t\t\t}\n\t\t\t\tif (parser.toksuper != -1) {\n\t\t\t\t\ttokens[uint(parser.toksuper)].size++;\n\t\t\t\t}\n\t\t\t\ttoken.jsmnType = (c == 0x7b ? JsmnType.OBJECT : JsmnType.ARRAY);\n\t\t\t\ttoken.start = parser.pos;\n\t\t\t\ttoken.startSet = true;\n\t\t\t\tparser.toksuper = int(parser.toknext - 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// closing curly parentheses or brackets\n\t\t\tif (c == 0x7d || c == 0x5d) {\n\t\t\t\tJsmnType tokenType = (\n\t\t\t\t\tc == 0x7d ? JsmnType.OBJECT : JsmnType.ARRAY\n\t\t\t\t);\n\t\t\t\tbool isUpdated = false;\n\t\t\t\tfor (i = parser.toknext - 1; i >= 0; i--) {\n\t\t\t\t\ttoken = tokens[i];\n\t\t\t\t\tif (token.startSet && !token.endSet) {\n\t\t\t\t\t\tif (token.jsmnType != tokenType) {\n\t\t\t\t\t\t\t// found a token that hasn't been closed but from a different type\n\t\t\t\t\t\t\treturn (RETURN_ERROR_INVALID_JSON, tokens, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.toksuper = -1;\n\t\t\t\t\t\ttokens[i].end = parser.pos + 1;\n\t\t\t\t\t\ttokens[i].endSet = true;\n\t\t\t\t\t\tisUpdated = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isUpdated) {\n\t\t\t\t\treturn (RETURN_ERROR_INVALID_JSON, tokens, 0);\n\t\t\t\t}\n\t\t\t\tfor (; i > 0; i--) {\n\t\t\t\t\ttoken = tokens[i];\n\t\t\t\t\tif (token.startSet && !token.endSet) {\n\t\t\t\t\t\tparser.toksuper = int(i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (i == 0) {\n\t\t\t\t\ttoken = tokens[i];\n\t\t\t\t\tif (token.startSet && !token.endSet) {\n\t\t\t\t\t\tparser.toksuper = int(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// 0x42\n\t\t\tif (c == '\"') {\n\t\t\t\tr = parseString(parser, tokens, s);\n\n\t\t\t\tif (r != RETURN_SUCCESS) {\n\t\t\t\t\treturn (r, tokens, 0);\n\t\t\t\t}\n\t\t\t\t//JsmnError.INVALID;\n\t\t\t\tcount++;\n\t\t\t\tif (parser.toksuper != -1) tokens[uint(parser.toksuper)].size++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// ' ', \\r, \\t, \\n\n\t\t\tif (c == \" \" || c == 0x11 || c == 0x12 || c == 0x14) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// 0x3a\n\t\t\tif (c == \":\") {\n\t\t\t\tparser.toksuper = int(parser.toknext - 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c == \",\") {\n\t\t\t\tif (\n\t\t\t\t\tparser.toksuper != -1 &&\n\t\t\t\t\ttokens[uint(parser.toksuper)].jsmnType != JsmnType.ARRAY &&\n\t\t\t\t\ttokens[uint(parser.toksuper)].jsmnType != JsmnType.OBJECT\n\t\t\t\t) {\n\t\t\t\t\tfor (i = parser.toknext - 1; i >= 0; i--) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttokens[i].jsmnType == JsmnType.ARRAY ||\n\t\t\t\t\t\t\ttokens[i].jsmnType == JsmnType.OBJECT\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif (tokens[i].startSet && !tokens[i].endSet) {\n\t\t\t\t\t\t\t\tparser.toksuper = int(i);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Primitive\n\t\t\tif (\n\t\t\t\t(c >= \"0\" && c <= \"9\") ||\n\t\t\t\tc == \"-\" ||\n\t\t\t\tc == \"f\" ||\n\t\t\t\tc == \"t\" ||\n\t\t\t\tc == \"n\"\n\t\t\t) {\n\t\t\t\tif (parser.toksuper != -1) {\n\t\t\t\t\ttoken = tokens[uint(parser.toksuper)];\n\t\t\t\t\tif (\n\t\t\t\t\t\ttoken.jsmnType == JsmnType.OBJECT ||\n\t\t\t\t\t\t(token.jsmnType == JsmnType.STRING && token.size != 0)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn (RETURN_ERROR_INVALID_JSON, tokens, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tr = parsePrimitive(parser, tokens, s);\n\t\t\t\tif (r != RETURN_SUCCESS) {\n\t\t\t\t\treturn (r, tokens, 0);\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t\tif (parser.toksuper != -1) {\n\t\t\t\t\ttokens[uint(parser.toksuper)].size++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// printable char\n\t\t\tif (c >= 0x20 && c <= 0x7e) {\n\t\t\t\treturn (RETURN_ERROR_INVALID_JSON, tokens, 0);\n\t\t\t}\n\t\t}\n\n\t\treturn (RETURN_SUCCESS, tokens, parser.toknext);\n\t}\n\n\tfunction getBytes(\n\t\tstring memory json,\n\t\tuint start,\n\t\tuint end\n\t) internal pure returns (string memory) {\n\t\tbytes memory s = bytes(json);\n\t\tbytes memory result = new bytes(end - start);\n\t\tfor (uint i = start; i < end; i++) {\n\t\t\tresult[i - start] = s[i];\n\t\t}\n\t\treturn string(result);\n\t}\n\n\t// parseInt\n\tfunction parseInt(string memory _a) internal pure returns (int) {\n\t\treturn parseInt(_a, 0);\n\t}\n\n\t// parseInt(parseFloat*10^_b)\n\tfunction parseInt(string memory _a, uint _b) internal pure returns (int) {\n\t\tbytes memory bresult = bytes(_a);\n\t\tint mint = 0;\n\t\tbool decimals = false;\n\t\tbool negative = false;\n\t\tfor (uint i = 0; i < bresult.length; i++) {\n\t\t\tif ((i == 0) && (bresult[i] == \"-\")) {\n\t\t\t\tnegative = true;\n\t\t\t}\n\t\t\tif ((uint8(bresult[i]) >= 48) && (uint8(bresult[i]) <= 57)) {\n\t\t\t\tif (decimals) {\n\t\t\t\t\tif (_b == 0) break;\n\t\t\t\t\telse _b--;\n\t\t\t\t}\n\t\t\t\tmint *= 10;\n\t\t\t\tmint += int(uint256(uint8(bresult[i]))) - 48;\n\t\t\t} else if (uint8(bresult[i]) == 46) decimals = true;\n\t\t}\n\t\tif (_b > 0) mint *= int(10 ** _b);\n\t\tif (negative) mint *= -1;\n\t\treturn mint;\n\t}\n\n\tfunction uint2str(uint i) internal pure returns (string memory) {\n\t\tif (i == 0) return \"0\";\n\t\tuint j = i;\n\t\tuint len;\n\t\twhile (j != 0) {\n\t\t\tlen++;\n\t\t\tj /= 10;\n\t\t}\n\t\tbytes memory bstr = new bytes(len);\n\t\tuint k = len - 1;\n\t\twhile (i != 0) {\n\t\t\tbstr[k--] = bytes1(uint8(48 + (i % 10)));\n\t\t\ti /= 10;\n\t\t}\n\t\treturn string(bstr);\n\t}\n\n\tfunction parseBool(string memory _a) internal pure returns (bool) {\n\t\tif (strCompare(_a, \"true\") == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction strCompare(\n\t\tstring memory _a,\n\t\tstring memory _b\n\t) internal pure returns (int) {\n\t\tbytes memory a = bytes(_a);\n\t\tbytes memory b = bytes(_b);\n\t\tuint minLength = a.length;\n\t\tif (b.length < minLength) minLength = b.length;\n\t\tfor (uint i = 0; i < minLength; i++)\n\t\t\tif (a[i] < b[i]) return -1;\n\t\t\telse if (a[i] > b[i]) return 1;\n\t\tif (a.length < b.length) return -1;\n\t\telse if (a.length > b.length) return 1;\n\t\telse return 0;\n\t}\n}\n"
    },
    "interfaces/IGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IGateway {\n\tstruct ExecutionInfo {\n\t\tbytes user_key;\n\t\tbytes user_pubkey;\n\t\tstring routing_code_hash;\n\t\tstring task_destination_network;\n\t\tstring handle;\n\t\tbytes12 nonce;\n\t\tuint32 callback_gas_limit;\n\t\tbytes payload;\n\t\tbytes payload_signature;\n\t}\n\n\tfunction send(\n\t\tbytes32 _payloadHash,\n\t\taddress _userAddress,\n\t\tstring calldata _routingInfo,\n\t\tExecutionInfo calldata _info\n\t) external payable;\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}